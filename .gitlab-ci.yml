include:
  - project: 'subugoe/argo-cd-workflow'
    file:
      # trigger downstream cross-project pipeline to update the helm chart; triggered on pushing a new tag
      - 'ci-templates/trigger-downstream-pipeline.yml'


# prevent included job from running unconfigured
trigger-downstream-pipeline:
  rules:
    - when: never

variables:
  imageTag: ${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA} # set this value also for trigger-downstream-pipeline-dev - using the variable in the trigger job results in re-evaluation of the predefined variables in the downstream project leading to different tags
  harborPath: "sub-fe/digis"
  dest: "harbor.gwdg.de/${harborPath}/${CI_PROJECT_NAME}"

.dev-rules:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_TAG
      when: never

.staging-rules:
  rules:
    - if: $CI_COMMIT_TAG

.kaniko_template: &kaniko
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  before_script:
    # add docker credentials
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"harbor.gwdg.de\":{\"auth\":\"$(printf "%s:%s" "robot\$sub-fe+sub-fe-digis" "${DIGIS_HARBOR_ROBOT_TOKEN}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
  script:
    - /kaniko/executor
      --context "${CI_PROJECT_DIR}"
      --dockerfile "${CI_PROJECT_DIR}/Dockerfile"
      --build-arg build_date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
      --build-arg vcs_ref=${CI_COMMIT_SHORT_SHA}
      --build-arg API_TOKEN=${API_TOKEN}
      --build-arg API_BASE_URL=${API_BASE_URL}
      --build-arg NUXT_APP_BASE_URL=${NUXT_APP_BASE_URL}
      --build-arg API_EXPERT_TOKEN=${API_EXPERT_TOKEN}
      --build-arg API_EXPERT_URL=${API_EXPERT_URL}
      --destination ${dest}

build_image_dev:
  <<: *kaniko
  script:
    - /kaniko/executor
      --context "${CI_PROJECT_DIR}"
      --dockerfile "${CI_PROJECT_DIR}/Dockerfile"
      --build-arg build_date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
      --build-arg vcs_ref=${CI_COMMIT_SHORT_SHA}
      --build-arg API_TOKEN=${API_TOKEN}
      --build-arg API_BASE_URL=${API_BASE_URL_DEV}
      --build-arg NUXT_APP_BASE_URL=${NUXT_APP_BASE_URL_DEV}
      --build-arg API_EXPERT_TOKEN=${API_EXPERT_TOKEN}
      --build-arg API_EXPERT_URL=${API_EXPERT_URL}
      --reproducible
      --destination ${dest}:${imageTag}
      --destination ${dest}:latest
  rules:
    - !reference [.dev-rules, rules]

# Override variables and rules for included trigger job
trigger-downstream-pipeline-dev:
  extends: trigger-downstream-pipeline
  variables:
    REFERENCED_IMAGE: ${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA} # explicit interpolation of predefined variables here is necessary as using the global var wont work as expected
    FILE_PATH: envs/values-dev.yaml
    UPDATE_KEY: .image.tag
    REPOSITORY_PATH: fe/digis/georoc-frontend-helm
  rules:
    - !reference [.dev-rules, rules]

build_image_staging:
  <<: *kaniko
  script:
    - /kaniko/executor
      --context "${CI_PROJECT_DIR}"
      --dockerfile "${CI_PROJECT_DIR}/Dockerfile"
      --build-arg build_date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
      --build-arg vcs_ref=${CI_COMMIT_SHORT_SHA}
      --build-arg API_TOKEN=${API_TOKEN}
      --build-arg API_BASE_URL=${API_BASE_URL_STAGING}
      --build-arg NUXT_APP_BASE_URL=${NUXT_APP_BASE_URL_STAGING}
      --build-arg API_EXPERT_TOKEN=${API_EXPERT_TOKEN}
      --build-arg API_EXPERT_URL=${API_EXPERT_URL}
      --reproducible
      --destination ${dest}:${CI_COMMIT_TAG}
  rules:
    - !reference [.staging-rules, rules]

# Override variables and rules for included trigger job
trigger-downstream-pipeline-staging:
  extends: trigger-downstream-pipeline
  variables:
    REFERENCED_IMAGE: ${CI_COMMIT_TAG}
    FILE_PATH: envs/values-staging.yaml
    UPDATE_KEY: .image.tag
    REPOSITORY_PATH: fe/digis/georoc-frontend-helm
  rules:
    - !reference [.staging-rules, rules]

# this stage creates a new environment for the current branch.
pages:
  image: node:18
  rules:
    - when: manual
  script:
    - apt-get update -y
    - apt-get install -y jq
    - rm -rf public/*
    - IFS=',' read -ra branches_array <<< "$PAGES_BRANCHES"
    - |
      for PAGES_BRANCH_NAME in "${branches_array[@]}"
      do
          mkdir $PAGES_BRANCH_NAME
          cd $PAGES_BRANCH_NAME
          echo "====== Downloading archive from $PAGES_BRANCH_NAME branch ======"
          echo "https://gitlab.gwdg.de/api/v4/projects/$CI_PROJECT_ID/repository/archive.tar.gz?ref=$PAGES_BRANCH_LATEST_COMMIT_SHA"
          curl -H PRIVATE-TOKEN:$GITLAB_TOKEN "https://gitlab.gwdg.de/api/v4/projects/$CI_PROJECT_ID/repository/archive.tar.gz?sha=$PAGES_BRANCH_NAME" -o ./archive.tar.gz
          tar -xf archive.tar.gz
          EXTRACTED_DIR_NAME=$(find . -mindepth 1 -maxdepth 1 -type d | head -n 1 | xargs basename)
          mv $EXTRACTED_DIR_NAME/* .
          rm -rf $EXTRACTED_DIR_NAME
          npm ci
          echo "NUXT_APP_BASE_URL=/georoc-frontend/$PAGES_BRANCH_NAME/" >> .env
          npm run generate
          mkdir --parents ../public/$PAGES_BRANCH_NAME
          cp --recursive .output/public/* ../public/$PAGES_BRANCH_NAME/
          cd ..
      done
      ls -la public

  environment:
    name: ${CI_COMMIT_REF_SLUG}
    url: https://subugoe.pages.gwdg.de/georoc-frontend/${CI_COMMIT_REF_SLUG}/
  artifacts:
    name: "$CI_COMMIT_REF_SLUG"
    paths:
      - public


# TODO: Find workflow for prod
#build_liveimage:
#  <<: *kaniko
#  # we just add the “live” tag here…
#  script:
#    - /kaniko/executor
#      --context .
#      --dockerfile ./Dockerfile
#      --build-arg build_date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
#      --build-arg vcs_ref=${CI_COMMIT_SHORT_SHA}
#      --destination ${IMAGE_TAG}
#      --destination $CI_REGISTRY:live
#  rules:
#    - if: $CI_COMMIT_TAG
#
